# 算法分析

> 来自mooc上姥姥的《数据结构》和课外的一些搜索.

### Lead-in

为什么要有算法？为什么要有数据结构？他们是帮助我们更好的解决一些实际问题。

姥姥举了放图书的例子。给你一堆书和一个书架，你打算如何把书放进书架？

这里要考虑两个问题：如何放新书？如何找到某本书？

显然最蠢的方法就是每次把新的书放到最后面，但这样找起书来就很麻烦。稍微聪明一点的方法是按书名的拼音去放书，这样可以快很多，更近一步可以像商店里把书分为“学习类”，“文学类”等，可以更近一步增加效率。可见算法帮助我们大大提高了效率。

***

### 复杂度

那什么是好的算法呢？我们引入空间复杂度和时间复杂度两个标准。

#### 空间复杂度 S(n)

这里姥姥用了一个例子：向屏幕中打印1--N个整数

* 方法一：做一个循环 

  ```c++
  for (i=1;i<=n;i++){
  	cout<<n<<endl;
  }
  ```

* 方法二： 递归

  ```c
  void PrintN(int N){
  	while (N){
  		PrintN(N-1);
  		printf("%d/n",N);
  	}
  	return ;
  }
  ```

虽然看起来都没问题，但其实方法二占用了很多了空间，当n很大时就罢工了。

<img src="C:\Users\阿漆\AppData\Roaming\Typora\typora-user-images\image-20220618115123115.png" alt="image-20220618115123115" style="zoom: 25%;" />

***

### 时间复杂度 O(n)

我们很关心算法执行的效率（即花了多少时间），为此引入时间复杂度的概念。

由于每台计算机性能不同，所以我们用所花时间与数据量n的关系来描述。

<img src="C:\Users\阿漆\AppData\Roaming\Typora\typora-user-images\image-20220618115459989.png" alt="image-20220618115459989" style="zoom: 25%;" /><img src="C:\Users\阿漆\AppData\Roaming\Typora\typora-user-images\image-20220618115626606.png" alt="image-20220618115626606" style="zoom:25%;" />

对于复杂度O(n!)，最著名的例子就是旅行推销员问题(Travelling salesman problem, TSP)：给定一系列城市和每对城市之间的距离，求解访问每一座城市一次并回到起始城市的最短回路。它是组合优化中的一个NP困难问题。解决这类问题没有什么好的算法，只能遍历所有可能解，然后比较各个解的优越性。对于TSP问题，第一次选择可以有n个，选定了第一个城市后，第二个城市的选择则有n-1个，以此类推，总共会有n!种不同的组合。因此，这类问题的算法复杂度是O(n!)。
<img src="C:\Users\阿漆\AppData\Roaming\Typora\typora-user-images\image-20220618115735882.png" alt="image-20220618115735882" style="zoom: 33%;" />

#### O记号

跟数分中的大O十分类似

如最大阶法则：O(2*n^2 + 10*n+1000) 即为O(n^2)

加法&乘法法则：见上图

#### 一些常见算法的时间复杂度

1. O(1)

    ```
     int i = 8;
     int j = 6;
     int sum = i + j;
     一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。
    ```

2. O(logn)

   ```
    i=1;
    while (i <= n)  {
      i = i * 2;
    }
   ```

   这里循环执行了log2（n）次，所以复杂度是O（logn)

   其实这与对数的底数无关，因为可以作为常数提出来。

3. O(m+n)、O(m*n)：如下，代码的复杂度由两个数据的规模来决定

   ```c
   int cal(int m, int n) {
     int sum_1 = 0;
     int i = 1;
     for (; i < m; ++i) {
       sum_1 = sum_1 + i;
     }
   
     int sum_2 = 0;
     int j = 1;
     for (; j < n; ++j) {
       sum_2 = sum_2 + j;
     }
   
     return sum_1 + sum_2;
   }
   ```

   从代码中可以看出，m 和 n 是表示两个数据规模。
   我们无法事先评估 m 和 n 谁的量级大，所以，上面代码的时间复杂度就是 O(m+n)。
